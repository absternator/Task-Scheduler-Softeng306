# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

# Visualisation

This section summaries the design decisions made for the visualisation part of
this project as well as how they are implemented.

## Interface elements

- ### Statistics Pane
This pane shows the information of the I/O, which includes the input file name, output file name and the number of processors assigned by the user.
 
Besides a timer, we include a status block in the middle of the statistics pane. It helps to indicate whether the algorithm is finished or not.
 
The statistics data that are related to the scheduling process is also included, which includes the number of complete, expanded, unexpanded, pruned solutions. It can help the user to have a better understanding of the algorithm process.
 
- ### Memory Pane
Memory pane shows how much memory is using during the runtime. It will keep updating even if the scheduling is finished so that user can have a clear understand of the memeory usage.

- ### Current Best Schedule
It shows the current best schedule that the algorithm generated.

- ### Node Graph
This is the visualisation of the input dot file. Users can easily drag the node to view the details of the graph.
 
## Design decision
- Instead of using different tabs, we decide to include all the information on one screen so that the user can easily compare them and do not need to switch between tabs.
 
- Several rounded rectangular is used to group related elements together.
 
- Different colours are used to achieve emphasis. For example, the colour of the status block will change from yellow to grey after the algorithm is finished.
 
## Frameworks, Library and used tools
- JavaFx
- Java Swing (for implementing the node graph)
- CSS
- TilesFx (for implementing the memory gauge)
- SceneBuilder

